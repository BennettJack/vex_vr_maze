{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\nfrom queue import PriorityQueue\nfrom collections import deque\nimport heapq\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n# Add project code in \"main\"\ndef main():\n    # Set robot to max speed\n    drivetrain.set_turn_velocity(100, PERCENT)\n    drivetrain.set_drive_velocity(100, PERCENT)\n    w , h = 8, 8\n    global maze\n    global startX, startY\n    global endX, endY\n    global route\n    global currentCell\n    global graph\n    global cellsToVisit\n    # Set start and end locations\n    startX, startY = 7,4\n    endX, endY = 0,3\n    # Instantiate maze\n    brain.clear()\n    route = []\n    maze = []\n\n    # Map the maze out in a 2D array, and add a new cell in each index\n    for i in range(w):\n        column = [] \n        for j in range(h):\n            column.append(Cell(i, j))\n        maze.append(column)\n\n    # Instantiate graph representation of the maze\n    graph = Graph()\n   \n    #Setup for the starting cell\n    currentCell = maze[startX][startY]\n    currentCell.gScore = 0\n    currentCell.fScore = currentCell.gScore + currentCell.hScore\n    cellsToVisit = []\n    cellsToVisit.append(currentCell)\n    \n    # Pen down to mark path\n    # Moves 10mm forward so robot is in middle of cell\n    pen.move(DOWN)\n    drivetrain.drive_for(FORWARD,10,MM)\n\n    # Scans the first cell\n    scan_cell()\n\n    # A Star is used to find the exit first\n    a_star(maze)\n\n    # Once A Star has found the exit, discover all other cells in the maze\n    fill_maze(maze, graph)    \n    \n    # Return to start from current location\n    pathToStart = breadth_first_search(graph, currentCell, maze[startX][startY])  \n    for cell in pathToStart:\n        visitCell(cell)  \n\n    # Finds path to end and marks it with green\n    pathToEnd = breadth_first_search(graph, currentCell, maze[endX][endY]) \n    pen.set_pen_color(GREEN)\n    for cell in pathToEnd:\n       \n        cell.partOfFastestRoute = True\n        visitCell(cell) \n    print_maze()\n    print_fastest_path(pathToEnd)\n\n\n    # Orientates robot to leave the maze\n    foundExit = False\n    while foundExit == False:\n        if (front_distance.get_distance(MM) > 2999):\n            drivetrain.drive_for(FORWARD, 250, MM)\n            foundExit = True\n        else:\n            drivetrain.turn_for(RIGHT,90,DEGREES)\n\n\n# A function to print the fastest path     \ndef print_fastest_path(path):\n    brain.new_line()\n    brain.print(\"Fastest path step count: \" + str(len(path)))  \n    for cell in path:\n        brain.new_line()\n        cell.print_coords()\n        brain.print(\" --> \")\n       \n\n\n# A function which takes a cell object and allows the robot to face and move to it\ndef visitCell(neighbour):\n    global currentCell\n    global cellsToVisit\n    if(neighbour.xCoordinates < currentCell.xCoordinates):\n        drivetrain.turn_to_heading(0,DEGREES)\n        drivetrain.drive_for(FORWARD,250, MM)\n\n\n    elif(neighbour.yCoordinates > currentCell.yCoordinates):\n        drivetrain.turn_to_heading(90, DEGREES)\n        drivetrain.drive_for(FORWARD,250, MM)\n\n    elif(neighbour.xCoordinates > currentCell.xCoordinates):\n        drivetrain.turn_to_heading(180, DEGREES)\n        drivetrain.drive_for(FORWARD,250, MM)\n\n\n    elif(neighbour.yCoordinates < currentCell.yCoordinates):\n        drivetrain.turn_to_heading(270, DEGREES)\n        drivetrain.drive_for(FORWARD,250, MM)\n    \n    currentCell = maze[neighbour.xCoordinates][neighbour.yCoordinates]\n\n    # if this cell hasn't been scanned yet, scan it\n    if(currentCell.scanned is False): \n        scan_cell()\n\n# A function which implements the A Star algorithm\n# This version is a little more greedy as it prioritises the cell which is 'closer' to the end as we will be\n# discovering the whole maze anyway\ndef a_star(maze):\n    global currentCell\n    global graph\n    path = []\n\n    priorityQueue = []\n    previousCell = currentCell\n    count = 0\n    \n    if count == 0:\n        path.append(currentCell)\n    while True:\n        # For each of the current cell's neighbours, find how many steps away they are from the start and how close they are to the end\n        for neighbour in graph.graph[currentCell]:\n            count += 1\n            temp_g_score = currentCell.gScore + 1\n            temp_f_score = temp_g_score + neighbour.hScore\n\n            #If the temporary score to the neighbour is lower than the neighbour's current score, add it to the priority queue\n            # This is done so that A Star doesn't try to backtrack to cells it has already visited\n            if temp_f_score < neighbour.fScore:\n                neighbour.gScore = temp_g_score\n                neighbour.fScore = temp_f_score\n                # Normally the f score would be the highest priority, however the heuristics score is used as the highest prio here\n                heapq.heappush(priorityQueue,(  neighbour.hScore, neighbour.fScore, count, neighbour,) )\n\n\n        # Retrieve the highest priority tuple, and get the cell value\n        cellToVisit = heapq.heappop(priorityQueue)[3]\n\n\n        # Slight optimisation to prevent robot from going to a cell which is known to be a dead end based on number of walls that\n        # surrounds it\n        isDeadEnd = True\n\n        while isDeadEnd:\n            if cellToVisit.wallCount < 3:\n               \n                isDeadEnd = False\n            else:\n                brain.print(\"is dead end\")\n                cellToVisit = heapq.heappop(priorityQueue)[3]\n\n\n        #If the cell to visit is a direct neighbour of the current cell, visit it\n        if cellToVisit in graph.graph[currentCell]:\n            visitCell(cellToVisit)\n            path.append(cellToVisit)\n\n        #If the cell to visit is not a direct neighbour, find the fastest path there and visit it\n        else:\n            pathToFollow = breadth_first_search(graph, currentCell, cellToVisit)\n            for cell in pathToFollow:\n                visitCell(cell)\n\n        #If the exit has been found, end A Star\n        if down_eye.detect(RED):\n            break\n\n# A function to visit all unvisited cells in the fastest way\ndef fill_maze(maze, graph):\n    \n    # Whilst there are still cells to visit, find the shortest path to each unvisited cell\n    # Find the shortest path, and follow the fastest path to it.\n    while len(cellsToVisit) > 0:\n        paths = []\n        for cell in cellsToVisit:\n            path = breadth_first_search(graph, currentCell, cell)\n            paths.append(path)\n\n        closestPath = paths[0]\n        for path in paths:\n            if(len(path) < len(closestPath)):\n                closestPath = path\n                \n        for cell in closestPath:\n            visitCell(cell)\n\n\n\n#A class representing each cell\nclass Cell:\n    def __init__(self, w, h):\n        self.xCoordinates, self.yCoordinates = w, h\n        # Up, right, down, left\n        self.walls = [False, False, False, False]\n        self.sideScanned = [False, False, False, False]\n        self.wallCount = 0\n        self.discovered = False\n        self.scanned = False\n\n        # Scores for A Star algorithm\n        # Best case distance from exit (heuristic)\n        self.hScore = abs(self.xCoordinates - endX) + abs(self.yCoordinates - endY)\n        # Steps from start\n        self.gScore = float('inf')\n        self.fScore = self.gScore + self.hScore\n\n        self.partOfFastestRoute = False\n\n        # As the maze is 8x8, slightly more efficient to assume that the sides are walls\n        if(self.xCoordinates == 0) and (self.yCoordinates != 3):\n            self.walls[0] = True\n        if(self.xCoordinates == 7) and (self.yCoordinates != 4):\n            self.walls[2] = True\n        if(self.yCoordinates == 0):\n            self.walls[3] = True\n        if(self.yCoordinates == 7):\n            self.walls[1] = True\n\n    # A function to print the coordinats of the cell\n    def print_coords(self):\n        brain.print(\"(X: \")\n        brain.print(self.xCoordinates)\n        brain.print(\" , Y: \")\n        brain.print(self.yCoordinates)\n        brain.print(\")\")\n    \n    # A function to set the amount of walls a cell has based on what walls have been discovered\n    def calculate_walls(self):\n        tempWallCount = 0\n        for wall in self.walls:\n            if wall is True:\n                tempWallCount += 1\n        \n        self.wallCount = tempWallCount\n        \n\n\n# A function which scans all four sides of a cell to discover walls and neighbours\n# If a side has already been scanned due to a neighbouring cell being scanned, the wall\n# will be ignored here\ndef scan_cell():\n    global currentCell\n    global graph\n    global cellsToVisit\n\n    \n    # Ensures program doesn't go out of bounds of the maze array\n    if (currentCell.xCoordinates - 1) == -1:\n        currentCell.walls[0] = True\n        currentCell.sideScanned[0] = True\n\n    elif currentCell.sideScanned[0] is False:\n        # References the cell above\n        cellAbove = maze[currentCell.xCoordinates -1][currentCell.yCoordinates]\n        drivetrain.turn_to_heading(0,DEGREES)\n        #If there is not a wall infront of the robot, add the cell ahead as a neighbour, and\n        #Mark the neighbouring cells oposit side as scanned so it wont be scanned in future\n        if(front_distance.get_distance(MM) > 70):\n            if cellAbove.scanned is False:\n                graph.add_edge(currentCell, cellAbove)\n                graph.add_edge(cellAbove, currentCell)\n                cellAbove.discovered = True\n                cellAbove.sideScanned[2] = True\n                # Stores the cell above to visit later when we need to discover whole maze\n                if cellAbove not in cellsToVisit:\n                    cellsToVisit.append(cellAbove)\n        #If a wall is found, set the top wall of the current cell to true, and the opposite wall of the cell above to true\n        else:\n            currentCell.walls[0] = True\n            currentCell.sideScanned[0] = True\n            cellAbove.walls[2] = True\n            cellAbove.sideScanned[2] = True\n            cellAbove.calculate_walls()\n\n    if(currentCell.yCoordinates +1 ) == 8:\n        currentCell.walls[1] = True\n        currentCell.sideScanned[1] = True\n        pass\n    elif currentCell.sideScanned[1] is False:\n        cellToRight = maze[currentCell.xCoordinates][currentCell.yCoordinates +1]\n        drivetrain.turn_to_heading(90,DEGREES)\n        if(front_distance.get_distance(MM) > 70):\n            if cellToRight.scanned is False:\n                graph.add_edge(currentCell, cellToRight)\n                graph.add_edge(cellToRight, currentCell)\n                cellToRight.discovered = True\n                cellToRight.sideScanned[3] = True\n                if cellToRight not in cellsToVisit:\n                    cellsToVisit.append(cellToRight)\n        \n        \n        else:        \n            currentCell.walls[1] = True\n            currentCell.sideScanned[1] = True\n            cellToRight.walls[3] = True\n            cellToRight.sideScanned[3] = True\n            cellToRight.calculate_walls()\n\n\n    if (currentCell.xCoordinates + 1) == 8:\n        currentCell.walls[2] = True\n        currentCell.sideScanned[2] = True\n        pass\n    elif currentCell.sideScanned[2] is False:     \n        drivetrain.turn_to_heading(180,DEGREES)\n        cellBelow = maze[currentCell.xCoordinates +1][currentCell.yCoordinates]\n        if(front_distance.get_distance(MM) > 70):\n            if cellBelow.scanned is False:\n                graph.add_edge(currentCell, cellBelow)\n                graph.add_edge(cellBelow, currentCell)\n                cellBelow.discovered = True\n                cellBelow.sideScanned[0] = True\n                if cellBelow not in cellsToVisit:\n                    cellsToVisit.append(cellBelow)\n    \n        else:   \n            currentCell.walls[2] = True\n            currentCell.sideScanned[2] = True\n            cellBelow.walls[0] = True\n            cellBelow.sideScanned[0] = True\n            cellBelow.calculate_walls()\n\n\n    if(currentCell.yCoordinates -1 ) == -1:\n        currentCell.walls[3] = True\n        currentCell.sideScanned[3] = True\n        pass\n    elif currentCell.sideScanned[3] is False:\n        drivetrain.turn_to_heading(270,DEGREES)\n        cellToLeft = maze[currentCell.xCoordinates ][currentCell.yCoordinates-1]\n        if(front_distance.get_distance(MM) > 70):\n            if cellToLeft.scanned is False:\n                graph.add_edge(currentCell, cellToLeft)\n                graph.add_edge(cellToLeft, currentCell)\n                cellToLeft.discovered = True\n                cellToLeft.sideScanned[1] = True\n                if cellToLeft not in cellsToVisit:\n                    cellsToVisit.append(cellToLeft)\n            \n        else:\n\n            currentCell.walls[3] = True\n            currentCell.sideScanned[3] = True\n            cellToLeft.walls[1] = True\n            cellToLeft.sideScanned[1] = True\n            cellToLeft.calculate_walls()\n            \n    # Once the cell has been scanned, \n    currentCell.scanned = True\n    cellsToVisit.remove(currentCell)\n\n    print_maze()\n\n\n\n# A class which stores the maze in graph form\nclass Graph:\n    def __init__(self, graph: dict = {}):\n        self.graph = graph\n\n    # Adds edges connecting each of cell1's neighbours\n    def add_edge(self, cell1, cell2):\n        if cell1 not in self.graph:\n            self.graph[cell1]= []\n        \n        self.graph[cell1].append(cell2)\n\n\n\n\n# A function to execute a breadth first search between two cells\ndef breadth_first_search(graph, startCell, targetCell):\n    \n    visited = {}\n    queue = deque()\n\n    visited[startCell] = None\n    queue.append(startCell)\n\n    #Whilst the queue is not empty, take the first element of the queue and explore it's neighbours\n    #Once the neighbour has been visited, store it and visit the next neighbour\n    #Once the target cell has been reached, reverse the visited path\n    while queue:\n        cell = queue.popleft()\n\n        if cell == targetCell:\n            path = []\n            \n            while cell:\n                path.append(cell)\n                cell = visited[cell]\n\n            return path[::-1]\n\n        for neighbour in graph.graph[cell]:\n            if neighbour not in visited:\n                visited[neighbour] = cell\n                queue.append(neighbour)\n                \n\n\n# Prints a visual representation of the maze in the console\ndef print_maze():\n    global currentCell\n    brain.clear()\n    currentCellRow = 0\n    currentCellColumn = 0\n    for row in maze:\n        print_divider(row, currentCellRow)\n        currentCellRow += 1\n        print_barrier(row, currentCellColumn)\n        currentCellColumn += 1\n        wait(0.1,MSEC)\n\n    endRow = maze[0]\n    print_divider(endRow, currentCellRow)\n   \n\n# Prints dividers for the top and bottom of each row\n# This function only accounts for the top wall of a cell\ndef print_divider(row, currentCellRow):\n    brain.new_line()\n    firstCellInRow = True\n    # The first and last row of cells will always be walls\n    if((currentCellRow == 0) or (currentCellRow == 8)):\n        for cell in row:\n            if(firstCellInRow):\n                brain.print(\"+----+\")\n                firstCellInRow = False\n            else:\n                brain.print(\"----+\")\n    else:\n        # If the top wall of a cell is a wall, print a wall\n        # The first cell in the row has an extra + for visual consistency\n        for cell in row:\n            if(firstCellInRow):\n                if(cell.walls[0] == False):\n                    brain.print(\"+    +\")\n                else:\n                    brain.print(\"+----+\")\n                firstCellInRow = False\n\n\n            else:\n                if(cell.walls[0] == False):\n                    brain.print(\"    +\")\n                else:\n                    brain.print(\"----+\")\n    \n\n\n# A function which prints barriers for each column\n# This function only accounts for the right wall of a cell\ndef print_barrier(row, currentCellColumn):\n    global currentCell\n    firstCellInRow = True\n    rowsPrinted = 0\n    # rowsPrinted has a limit of two as two barriers are used to make a square\n    while(rowsPrinted < 2):\n        brain.new_line()\n        for cell in row:\n            #The first cell will always have an extra | to the left\n            if(firstCellInRow):\n                # If the cell has a wall to the right, print a wall\n                # If the wall is part of the fastest route, print an X\n                if(cell.walls[1] == True):\n                    if(rowsPrinted == 0):\n                        brain.print(\"|    |\")\n                    if(rowsPrinted == 1):\n                        if cell.partOfFastestRoute:\n                            brain.print(\"|  x |\")\n                        else:\n                            brain.print(\"|    |\")\n                else:\n                    if(rowsPrinted == 0):\n                        brain.print(\"|     \")\n                    if(rowsPrinted == 1):\n                        if cell.partOfFastestRoute:\n                            brain.print(\"|  x  \") \n                        else:\n                            brain.print(\"|     \") \n                firstCellInRow = False\n            # For cells that are not the first in the row\n            elif(cell.walls[1] == True):\n                if(rowsPrinted == 0):\n                    brain.print(\"    |\")\n                if(rowsPrinted == 1):\n                    if cell.partOfFastestRoute:\n                        brain.print(\"  x |\")\n                    else:\n                        brain.print(\"    |\")\n\n            else:\n                if(rowsPrinted == 0):\n                    brain.print(\"     \")\n                if(rowsPrinted == 1):\n                    if cell.partOfFastestRoute:\n                        brain.print(\"  x  \") \n                    else:\n                       brain.print(\"     \") \n            \n        rowsPrinted += 1\n        firstCellInRow = True\n\n\n\n# VR threads — Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}